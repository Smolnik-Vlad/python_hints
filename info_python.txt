ctrl+alt+L - все подравнять
github1s.com

Файлы для гита: MakeFile, req.txt, README.md, env (мкесто для хранения переменных повышенной секретности)

Все для создания площадки для работы Виртуальное окружение и requirements
python -m venv venv - создание виртуального окружения
source venv/bin/activate - подключение виртуального окружения (linux)
venv\Scripts\activate (wind) 
pip install -r requirements.txt - установка с requirements (не должно быть ошибок, а то не загрузится в venv)

pip freeze - получить все библиотеки и их версию
pip freeze > requirements.txt - создает файл requirements, куда записывает все требования (потом закидывается в гит вместо виртуального окуржения)


touch Makefile - создание файла, который содержит функции, выполняющие настройки проекта (в файле пишутся баш скрипты)
make run - запуск функции из Makefile

env(хранение различных кодов)

#Если не видит библиотеку
pip3 uninstall telebot
pip3 uninstall PyTelegramBotAPI
pip3 install pyTelegramBotAPI
pip3 install --upgrade pyTelegramBotAPI
#

import sys
python file.py 1 2 3 - передача аргумента в список библиотеки sys: sys.argv={1, 2, 3}

	# - однострочный коммент
'''a''' - многострочный коммент	

a.__dict__ - узнать все функции объекта
a.__doc__ - получить документацию об объекте
a.__sizeof__ - узнать размер данных





	Типы данных, переменные, работа с переменными
id(a) - узнать адрес памяти
type(a) - узнать тип переменной int(input()) - преобразование из строки в целое число
isinstance(a, (int, float)) - возвращает 1 или 0, первый аргумент - переменная, второй - кортеж с возможными типами данных


float(input()) - преобразование из строки в любое число
float('inf') - положительная бесконечность
float('-inf') - отрицательная бесконечность 
float('nan') - чистое ничего 


bool() - логический тип данных
str() -перевод символа в строку
int('a', b) - в целое число, b - аргумант, обозначающий систему исчисления (двоичная и тд)
	

	Аннотации (для разработчика, т.е. только подсвечивает)

a: int = 5 - переменная принимает только int значения
def funct(a: int, b: int=11 )->int - добавляем аннотацию в функцию, аргументы определенного типа, return определенного типа
funct.__annotation__  - получить аннотацию

Для коллекций:
from typing import List, Tuple, Dict - используем библиотеку для аннотации коллекций
lst: List[str] - список будет состоять только из строк
d: Dict[str, int] = {'a': 100} словарь с аннотацией


Сборка:
from typing import Any, Union, Optional

a: Any = 1 - любой тип данных
b: Optional[int] = None - переменная принимает либо ничего, либо int
с: Union[int, str] - может принимать несколько значений
с: int|str - Union




	Формы операторов присваивания

a = 'a'                 # Каноническая форма
a, b = 'A', 'b'         # Присваивание кортежей
[a, b] = ['A', 'b']     # Присваивание списков
a, b, c, d = 'test'     # Присваивание последовательностей (каждой букве соответсвует символ строки)
a, *b = 'test'          # Операция распаковки последов (*b берет оставшиеся части строки).
a = b = 'test'          # Групповое присвоение одного знач.
a += 1                  # Комбинированная инструкция присв.
a, b = b, a             # Обмен значениями
x1, x2, x3 = false, 1, a - распаковка ( присваивание идет по очереди)
1<=a<=100 - упрощение записи

	Запаковка/Распаквка

num=[1, 2, 3, 4]
more_num=[*num, 11, 18] - распаковка, то есть весь список/множество/кортеж/ключ словаря превращаются в обычне значения(не длежат в одной "ячейке")

a, *b=1, 2, 3 - запаковка, т.е. в b входят оставшиеся элементы

date_info = {'year': '2020', 'month': '01', 'day': '7'}
>>> event_info = {**date_info, 'group': "Python Meetup"} - распаковка словаря (удобно при создании нового словаря)

def f2(a, b, c,*container):     - когда объявлено в аргументах функции, то идет ЗАПАКОВКА (в кортежчё)
    return a, b, c, container
f2(1,2,3,4,5,6,7,8,9,0)
(1, 2, 3, (4, 5, 6, 7, 8, 9, 0)) 




	Функции ввода/вывода
name = imput ("ввод") - вводит в переменную данные с клавиатуры (в скобках указ. требования)
a, b, c = input() - вводится безпрервывно, но на каждую букву соответственно один символ
input('Введите имя игрока № {}'.format(str(i+1))) - вместо фигурных скобок вставляется значение

print (name) - вывод 
print(1, 2, sep=".", end=".", file="file", flush) - : sep - способ разделения выводимых значений (изначально задан пробел)
						      end - как заканчивать вывод (изначаьлно \n)
						      file - в какой файл выводить (изнчально консоль)



		Строки
 len(s) - Узнать количество символов (длину строки) можно при помощи функции .
S[i] — это срез, состоящий из одного символа, который имеет номер i
S[0] - первый символ
S[-1] -последний символ 
S[:i] - читаются символы до i
S[i:] - читаются символы от i
a in b - строка a внутри строки b
len(l) - узнать длину строки l
S[a:b:d] - срез от a до b с шагом d


Методы
S.find("e") - находит первый индекс 'е' в строке, если такого символа нет, то выдаст -1
S.rfind("e") - находит последний индекс 'е' в строке
S.index(a) - возвращает индекс, если нету, выводит ошибку
S.split(' ') - разделяет строку на подстроки в местах пробела (в данном случае)
S.isdigit() - проверяет на цифры

s.count('aa') - находит колличество строк 'аа' в строке 
s.replase('a', 'A', 2) - замена первых 2 а на А в строке s
S.upper() - переводдит все к верхнему регистру
s.lower() - переводит все на нижний реистр
 print(“““ первая строка
вторая”””) - выводит на разных строках
s.join(a) - добавляет в строку список или другую строку	
S.capitalize() - делает, чтобы первое слово с большой буквы
S.title() - каждое слово с большой буквы
S.strip() - полученную строку приводит к строке со словами, разделенными пробелами
S.startswith("a") - проверяет, начинается ли строка с данного слова
S.endswith('string') - проверяет, заканчивается ли строка на данное слово
\n - enter




	Форматирование строк

Оператор %
'Hello, %s %s' %(first_name, last_name)	- первый способ
'Hello, %(first_name)s %(last_name)s' %('first_name':first_name, 'last_name':last_name) - c переменными
'Hello, %.1s%.1s' % (first_name, last_name) - берет только первую букву
print('%(x)f + %(y)f = %(z)f' % {'x': x, 'y': y, 'z': x + y}) - работа с числовыми значениями 

Метод .format
'Hello, {} {}!'.format(first_name, last_name) - вставляется по порядку
'Hello, {1} {0}!'.format(first_name, last_name) - вставляется по номеру
'Hello, {first_name} {last_name}!'.format(last_name=last_name, first_name=first_name) - втавляется по имени
print('{x:.2f} + {y:.2f} = {z:.2f}'.format(x=x, y=y, z=x + y)) - с использованием чисел и их дрбной частью

f-строки (f-string)
f'Hello, {first_name} {last_name}' - по переменным
print(f'{x:.2f} + {y:.2f} = {x + y:.2f}') - c числовыми значениями 



	Итерабельные типы данных (списки, словари, кортежи, множества)
___________________________________________________________________________________________________________________________________________	

		Списки
a=['1', 2, True]
a=list('123456') - перевод строки в список (a=['1', '2', '3', '4', '5', '6'])
 c = [c * 3 for c in 'list'] - генератор списка

Операторы:
a=[1]
a*n - список повторит каждый элемент n раз
a+b - объединяет два списка

Функции
len(a) - длина списка
min(a) - наименьший элемент списка
max(a) - наибольший элемент списка
sum(a) - сумма всех элементов (только числа)
list(zip(a, b)) - создает список кортежей (то есть объединяет несколько списков, множеств, кортежей или словарей в список кортежей)
list(zip("hello", (9,8,7,6,5), ["a","b","c","d","e"], "AAAAAAAAAAAAAAAAAAA", "BBBBBBBBBBBBBBB")) - объединяет все в список, берет размер контейнера с наименьшим размером

Методы
a=x.copy() или a=list(x) или a=x[:]- копирует список (если через приравнивание, то переменная указывает на одно и то же место, и при изменении одной переменной изменяется и другая)
f in a - проверяет, есть ли f
x.index(n) - вернет индекс первого найденного элемента
x.count(n) - вернет количество элементов
x.append(n) - добавляет новый элемент в конец списка
x.insert(a, 'test') - вставляет test в место со индексом a
x[2:5] = [1, 2, 3] - вместо среза вставляет РАСПАКОВАННЫЙ список
x.sort() - сортирует список
x.sort(
e = true) - сортирует список в обратном порядке
x.remove(n) - удаляет первый элемент 
x.pop() - удаляет последний элемент, выводит удвленный элемент
x.pop(2) - удаляет второй элемент с конца, выводит удвленный элемент
s=', '.join(x) - создает строку, слова которой является элементами списка, разделенными ', '
x.extend(listToAdd) - добавляет в список элементы с другого списка
x.clear() - очищает список
del list[a:b] - удалить в диапазон от а до b

Генератор 
[x * x for x in range(10)]
[x * x for x in range(10) if x % 2] - генератор с условием


	
	Кортеж
Объявление
x=tuple()
x=('a',) 
x=(1, 2, 3, 4, 5)
x=1, 2, 3

Операции
x=(1, 2)
y=(3, 4)
x, y = y, x - обмен значений

x.count('a') - количество a в кортеже
x.index('a') - ищет индекс a в кортеже


	Словарь
Объявление 
x={}
x=dict()
x={'Alex': None, 'Brian': {'age': 15, 'gender': male}} - словарь в словаре

Операции
x['key'] - вывод значения, если его нет, он создается (вывод значение делать )
x['Alex']={'age':17} - добавление нового элемента
x.del['Alex'] - удаляет 

Функции
dict(zip(a, b)) - создает словарь(то есть объединяет несколько списков, множеств, кортежей или словарей в список кортежей)

Методы 
x.update({'Alex':{'age':17}}) - перезаписываем словарь, то есть если есть такие элементы, они перезаписываются, если новые - добавляются
x.get('key') - вывод значения
x.pop() - удаляет последние значения
x.values() - возвращает все значения
x.keys() - возвращает все ключи
x.items() - возвращает все пары

Итерация по словарям
for key, value in x.items(): - вывод пар
	print(key, value)

{v:k for k, v in e2f.items()} - поменять местами ключ/значение

Генератор
{x: x**2 for x in range(10)}
{x: x**2 for x in range(10) if x % 2} - генератор с условием



	Множества (не имеют повторяющихся элементов)
Объявление:
x=set()
x={'x'}
x=set{'abc'} - вернет {'a', 'b', 'c'}

Операции:
A|B или A.union(B)- объединение
A&B или A.intersection(B) - пересечение
A-B - разность 
A^B - симметрическая разность

Методы 
x.add() - добавляет новый элемент (неизменяемыф)
sets.update(lists, tuples) - добавляет элементы с другого множества или множеств (может быть и кортежи, и списки и все остальное)
x.remove() - удаляет элемент
x.discard() - удаляет элемент, не выдет ошибку, если нет такого элемента
x.pop() - сохраняет элемент и удаляет первый элемент (быть аккуратнее, т.к. в множестве элементы хранятся не как их задают)
x.clear() - удаляет все 

Генератор
{x * x for x in range(10)}
{x * x for x in range(10) if x % 2} - генератор с условием

___________________________________________________________________________________________________________________________________________

	условия
str.isdigit() - определяет, числовое ли значение
if 

elif

else

x or y - или
x and y - и
not x - не 

x = 'да' if False else 'нет' - сокращенный оператор
x = 'да' if a else 'нет' - сокращенный оператор
x = 'да' if False else ('нет' if False else 'совсем нет') - сокращенная запись оператора в операторе

hot_temps = [temp for _ in range(20) if (temp := get_weather_data()) >= 100] - моржовый оператор (:=), сразу сравнивает и приравнивает 



	Цикл
While ...: зацикливающееся условие
if...
while true - бесконечный цикл
  for a in 1, 2, ... -  присваевает значения переменной а
range(n) - 	for a in n
range(n, k) - от n (включая) до k (не включая)
range(n, k, l) - от n (включая) до k (не включая) через каждый l

break - остановить цикл (тогда удыу не учавствует)
else - если не устраивает условию while
continue - пропустить команды в цикле
for i in range(n) - в промежутке n
for _ in range(5): - не создает новую переменную а использует "мусорку"

a=[i.capitalize() for i in a] - генератор 

matrix = [[i for i in range(5)] for _ in range(6)] - получается матрица
		
		

	


	черепашка
import turtle - извлечь черепшку из библиотеки
t = turtle.Pen() - присваивание черепашки к числу t (все действия будут записываться через t)
t.up/down() - поднять/опустить перо
goto(x, y) - переместить черепашку в точку с координатами (x, y).Обрати внимание, что она продолжит оставлять след, если не поднять перо.
setx(n) - задать координате x значение n.
sety(n) - задать координате y значение n.
home() - переместить черепашку в точку (0, 0).
t.forward/backward(50) - перенести черепашку вперед/назад на 50 пикселей
t.left/right(90) -  поворот черепашки на 90 
t.reset - очищение холста
t.clear - очищение холста,  но при этом черепашка остается на месте
xcor() - узнать координату x черепашки 
ycor() - узнать координату y черепашки 
pos() - вернет сразу два числа - координату x и y.
t.pencolor('red') - цвет пера красный
t.width(25) - толщина пера 25
fillcolor('red') - установить цвет заливки.
t.begin_fill() -  пишем в начале, тем самымы говорим черепашке, что начиная с этой точки будет начинаться заливка;
t.end_fill() - пишем в конце, после команд, которые рисуют фигуру, после чего черепашка зальет нарисованную область цветом.
t.color('red', 'blue') - устанавливает цвет пера и заливки



	Функция и все принадлежности
______________________________________________________________________________________________________________________________________________
4 доступа: global, local, enclosing(внутренняя функция использует поля внешней функции), build-in (подключение всяких библиотек)

def hello(param): 
	print( param); - создание  функции, def - функция, hello - имя функции, param - переменная или текст
	return A - возвращение значения, можно писать несколько аргументов, вернет как кортеж, можно разбить срау на переменные при возвращении

	pass - просто для пустой функции
hello(fgh) - вызов функции, где param = fgh
hello(x=1, y=2) - передается соответственно определенным аргументам (т.е. при создании ф-ии есть переменные, они соответствуют аргументам)

Виды объявления:
def funct()
def funct(x, y)
def funct(x, y=1) - с неявным аргументом (второй аргумент передавать необязательно), 
def funct(*args) - можно передавать несколько позиционных аргументов, args в функции является кортежем, запаковывает в кортеж введенные значения
	def funct(*args, a) передается как (1, a=2)
	def funct(a, *args) можно передавать по разному
def funct(**kwargs) - можно передавать ключ:значение
	my_dict={'a':1, 'b':2}
	funct(my_dict)
	func(x=0, y=1) - сделает из этого словарь соответственно


Значение аргументов по умолчанию (в частности для нецикличного повторения)
def func(x, y = None): - работа с иколлекционными значениями, поскольку y будет у всех одинаков, в случае использования имменованного y
  if y == None:
    y = []

  y.append(x)
  print(f'x = {x}, y = {y}')


Документация функции
def my_funct():
	"""Что-то"""
my_funct.__doc__ - вернет документацию
help(my_funct) - вернет документацию




	Lambda-функции (удобно, если функция маленькая)
def funct():...
a=funct - ссылка на функцию

f = lambda x: x**2 - объявление лямбда функции, где f - ссылка на функцию (переменная, которая ссылается на функцию), возвращает x**2

f=(lambda x: 'чётное' if x % 2 else 'не чётное') - можно использовать скобки, то есть возвращает любое значение 

ids = ['id1', 'id30', 'id2', 'id3', 'id22', 'id100']
sorted_ids = sorted(ids, key=lambda x: int(x[2:])) - сортирует похожие элементы через лямбда функцию


	Map, Filter, Reduce, Enumerate
map(even_odd,elements) - применяет функцию even_odd к каждому элементу итерабельного объекта elements
list(map(even_odd,elements)) - интерпретирование в список
elements_by2 = map(lambda x: x*2, elements) - c лямбда функцией


list(filter(funct, elements)) - фильтрует элементы списка elements по критериям функции funct
list(filter(lambda x: x>0, elements)) 

def is_digit(arg):
    return isinstance(arg, (float, int))
list(filter(is_digit, data)) # - проверка на float и int


res=reduce(sum, numbers) -применяет функцию двух аргументов кумулятивно к элементам итерируемого, необязательно начиная с начального аргумента. 
result = reduce(custom_sum, numbers, 10) - первым элементом будет 10

dict(enumerate('hello')) - представит hеllo ввиде словаря c ключом из чисел


	
	Декораторы  (функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.)

def decorator_function(func):      - функция-декоратор (передается функция как аргумент)
    def wrapper():		   - функция-обертка
        print('Функция-обёртка!')
        func()
        print('Выходим из обёртки')
    return wrapper


#декорирование функции через присваивание
def hello_world():		   -функция для декоратора
   print('Hello world!')
hello_world=decorator_function(hello_world) - 


#декорирование функции через синтаксический сахар
@decorator_function
def hello_world():
  print('Hello world!')

#декоратор с передачей аргументов
def dec1(a1,a2):			- передача аргументов
    def filter_decor(func):		- декоратор 
        def wrapper(*a, **kw):
            print("-----------", a1, a2)
            return func(*a, **kw)
        return wrapper
    return filter_decor

@dec1(1,2) - вначале выполняется соответствующая функция, в которую передаются аргументы(внешний декоратор), возвращает нам декоратор, потом вып. основной
def f():
    return True


lambda_dec = lambda par1, par2: lambda func: lambda *a, **k: func(*a[::-1], **k) - lambda-декоратор
@lambda_dec(1,2)
def func_1(a,b):
    return a ** b


#хороший пример, где в декорируемую функцию передается аргумент внешней функции
def my_filter_1(filt):
    def my_filter_2(funct):
        def my_filter_3(*values):
            print(filt)
            try:
                funct(list(values), filt)
            except ValueError:
                 print("Сработала ошибка!")
            finally:
                 print("Программа окончена!")
        return my_filter_3
    return my_filter_2

@my_filter_1(filt="Oleg")
def my_filter_4(values, *args):
    if args[0] in values:
        raise ValueError

my_filter_4("Ole", 1, 2)


#Класс-декоратор
class Decor_class:
    def __call__(self, funct):
        def decor():
            print("decorate_function")
            funct()
        return decor

decor_function=Decor_class()
@decor_function
def funct():
    print("funct")

funct()




#Дополнительная инофрмация (Документирование декараторов)
https://colab.research.google.com/drive/1H0BhiXhcre5GQWRYY7kyTM9ewK3LCn2a?usp=sharing#scrollTo=RH1SIMkm5cJr
https://colab.research.google.com/drive/13OkMX9e2fBZuS5d2re4sMgb8Y2mmWNJX?usp=sharing - особые декораторы
----------------------------------------------------------------------------------------------------------------------------------------------

	

	РАЗЛИЧНЫЕ МОДУЛИ
___________________________________________________________________________________________________________________________________________	
		

	Рандом
import random 
random.uniform(<Начало>, <Конец>) -  возвращает псевдослучайное вещественное число в диапазоне от <Начало> до <Конец>
random.randint(<Начало>, <Конец>) — возвращает псевдослучайное целое число в диапазоне от <Начало> до <Конец>
random.choice(<Последовательность>) — возвращает случайный элемент из любой последовательности (строки, списка, кортежа)
random.randrange(<Начало>, <Конец>, <Шаг>) — возвращает случайно выбранное число из последовательности
random.shuffle(<Список>) — перемешивает последовательность (изменяется сама последовательность). Поэтому функция не работает для неизменяемых объектов.


	Время
import time 

time.time() - количество секунд, прошедшее с начала нашей эпохи
time.ctime() - перевод секунд в удобный формат (если без аргумента, то вернет настоящую дату)
time.asctime() - получить точные данные о времени
time.sleep(n) - задержка программы на n секунд

result=time.gmtime() - получить данные в другом формате
result=time.localtime() - получить данные в другоом формате
result.tm_mday - получить отдельно день/месяц/минуту...

time_str=time.strtime('%m/%d/%Y, %H:%M:%S') - вывод даты и времени

 

	

-------------------------------------------------------------------------------------------------------------------------------------------

		Кодировка
ENCODE 
txt.encode(encoding='ascii', errors='backslashreplace')) - заменяет неизвестный символ (txt - строка, которую раскодируют)
				     backslashreplace - использовать обратный слэш (\) вместо проблемных символов
				     ignore - игнорировать проблемные символы
				     namereplace - заменить объяслением проблемного символа
				     strict- по умолчанию, вызвать ошибку
				     replace - использовать знак вопроса (?) вместо проблемных символов
				     xmlcharrefreplace - использовать символ xml вместо проблемных символов

DECODE
txt.decode(encoding='ascii', errors='backslashreplace' 
				     backslashreplace - использовать обратный слэш (\) вместо проблемных символов
				     ignore - игнорировать проблемные символы
				     namereplace - заменить объяслением проблемного символа
				     strict- по умолчанию, вызвать ошибку
				     replace - использовать знак вопроса (?) вместо проблемных символов
				     xmlcharrefreplace - использовать символ xml вместо проблемных символов






		Работа с файлом
___________________________________________________________________________________________________________________________________________
import shutil - доп библиотека для файлов
https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-open/ - подробнее

	Функция Open() - возвращает объект файла

file= open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
	file - абсолютное или относительное значение пути к файлу или файловый дескриптор открываемого файла.
	mode - необязательно, строка, которая указывает режим, в котором открывается файл. По умолчанию 'r'.
	encoding - необязательно, кодировка, используемая для декодирования или кодирования файла.
	errors - необязательно, строка, которая указывает, как должны обрабатываться ошибки кодирования и декодирования. Не используется в -бинарном режиме	
	newline - необязательно, режим перевода строк. Варианты: None, '\n', '\r' и '\r\n'. Следует использовать только для текстовых файлов.
	closefd - необязательно, bool, флаг закрытия файлового дескриптора.
	opener - необязательно, пользовательский объект, возвращающий открытый дескриптор файла.

mode='r'
	r - открывает файл только для чтения,
	w - открыт для записи (перед записью файл будет очищен),
	w - создаст новый файл, если такогого нету
	x - эксклюзивное создание, бросается исключение FileExistsError, если файл уже существует.
	a - открыт для добавления в конец файла (на некоторых Unix-системах пишет в конец файла вне зависимости от позиции курсора)
	a+ - символ обновления (чтение + запись).
	t - символ текстового режима.
	b - символ двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).


	Функции чтения файла и записи в файл

s=file.read() - прочитает весь файл (каретка переходит в конец)
s=file.read(n) - прочитает первые n символов (каретка переходит на n)
s=file.readline() - прочитает одну строку (доходит до /n и перемести на новою строку)
s=file.redlines() - создаст список, элементами которого будут являться строки 
file.seek(n) - откатить каретку на n-ый символ

for row in file: - по каждой строке из файла
	for letter in row: - по каждой букве из строки

with open('info.txt') as f: - выполнение нескольких функций дновременно 
  print(f.read())

file.write('hi') - запишет в файл
f.writelines(cfg_lines) - запишет список в файл



-------------------------------------------------------------------------------------------------------------------------------------------


		Модули для хранения данных
_________________________________________________________________________________________________________________________________________


	csv 
import csv

Чтение файла:
with open("name_of_file.csv") as data:
 data = csv.reader(f, delimiter=' ', quotechar='|') - переводит табличный формат в список со списками (как и json)
 reader = csv.DictReader(f) - возвращает список со  словарями

Запись:
with open('some.csv', 'w') as f:
 writer=csv.writer(f)
 writer.writerows(users)
	



	Json
https://realpython.com/python-json/

import json

with open("data_file.json", "w") as write_file:
    json.dump(data, write_file)   			- сериализует в тип json и записывает в файл
    json_string=json.dumbs(data)			- сериализует в тип json и просто все 
    json.dump/json.dumps(data, indent=n, )
			 indent -указывает размер отступа для вложенных структур 

    with open("data_file.json", "r") as read_file:
    data = json.load(read_file) 			-десериализация из файла

    data = json.loads(json_string) - десириализация из переменной или друой программы (например, json_string = """{"Name": "Vlad", "species": "Betelgeusian"}"""")

	
	
	

------------------------------------------------------------------------------------------------------------------------------------------

		ООП
https://colab.research.google.com/drive/1DJiG5NaAQhA_-51LKyXXRa8Il7spigYI?usp=sharing - презентация всего и вся
https://colab.research.google.com/drive/1yakB8h-SnqLaFOww27CyGHh8qwo79Nan?usp=sharing#scrollTo=LzuO5QMpG0K6 - по абстрактным, проперти
slef.__class__ - получить инфу о классе
isistance(x, Class) - проверяет причастие объекта к классу

Основные пологающие ООП: 
ИНКАПСУЛЯЦИЯ(то есть переменные типа public, protected, private):
	self.a - public
	self._b - protected
	self.__c - private (на самом деле меняет название на _classname__c)

НАСЛЕДОВАНИЕ:
class B:
 pass
class A:
 pass
class C (A, B) - наследуется от A и от B
 pass

a.mro() - вызывает последоватеьность классов (по порядку смотреть алгоритм С3-линеаризации)

super(Class, self).__init__(name) - вызывает init  класса-родителя, при этом если обрабатывается name, то оно будет и в нашем классе
a._Class__method() - 
super().met_1() - вызывает метод ближайшего класса родителя
super(D, self).met_1() - идет отталкивание от класса D, то есть разбор идет от класса D
можно вызвать метод класса роителя как Class.method(self) - то есть передается self из метода текущего класса



Полиморфизм возможность при одинаковом названии иметь различную реализацию)



	Магические методы (все магические методы переопределяют определенный метод для специального класса, в котором он описан)
https://habr.com/ru/post/186608/ - подробнее

def __new__(cls):	- метод, вызывающийся при создании объекта (конструктор)
	print("")
	return object.__new__(cls) - new с object, вызывается сразу после создания объекта (инициализатор)
def __init__(self):  - 


def __repr__(self) - для отображения информации об объекте класса в режиме отладки (для разработчиков, в основном исп в консоли при вызове метода)
def __str__(self) - для отображения информации об объекте класса для ползователей (при исп функций print, str)


def __len__() - позволяет применить функцию len() к экземплярам класса
def __abs__() - позволяет применить функцию abs() к экземплярам класса
def __del__(self) - переопределение метода del 

Методы сравнения(передается два объекта класса, и с них вызываются сравниваемые поля)
def __cmp__(self, other) - должен вернуть отрицательное число, если self < other, ноль, если self == other, и положительное число в случае self > other.
def __eq__(self, other) - Определяет поведение оператора равенства, ==
def __ne__(self, other) - Определяет поведение оператора неравенства, !=.
def __lt__(self, other) - Определяет поведение оператора меньше, <.
def __gt__(self, other) - Определяет поведение оператора больше, >.
def __le__(self, other) - Определяет поведение оператора меньше или равно, <=.
def __ge__(self, other) - Определяет поведение оператора больше или равно, >=.	


Арифметические методы(первый указатель указывает на объект, с которого вызывается, второй - c которым сравнивается):
__add__(self, other) Сложение.

__sub__(self, other) Вычитание.

__mul__(self, other) Умножение.

__floordiv__(self, other) Целочисленное деление, оператор //.

__div__(self, other) Деление, оператор /.





Абстракция (использование только тех характеристик объекта, 
которые с достаточной точностью представляют его в данной системе.) и интерфейс:

Абстрактный класс - базовый класс, который не предполагает создания экземпляров. Может содержать абстрактные методы и свойства
Интерфейс - как абстрактный класс только прям вообще не может содержать реализованные методы.

class MyInterface:
    hitpoints : int
    actpoints : int

    def move(self, a, v):
        "dock"

    def action(self):
        "dock"


Специальная библиотека для удобства работы с абстрактным классом:

from abc import ABC, abstractmethod

class SuperAbstractClass2(ABC): 

    @abstractmethod - метод, который обязательно нужно переопределить, от этого класса нельзя создать объекты
    def move(self):
        "dock"




Декораторы в ООП:
@staticmethod		- статический метод, то есть тот метод, который можно вызвать через сам класс и через его объект (равносильно обычной функции)
def say_hello():

@classmethod		- меняют состояние самого класса, то есть для всех объектов, передается класс
def add_numb(cls):



@property		- чтобя функцию можно было бы приставить как обычное поле
def name(self):
  return self.__name

 @balance.getter		- вывод значения (a=balance)
    def balance(self):
        print("getter")
        if input("enter pin: ") == str(self.__pin):
            return self.__balance
        return f"Wrong pin, your pin: {self.__pin}"

    @balance.setter						- ввод в поле (balance = a)
    def balance(self, result): # result = self.balance + 10
        print("setter")
        if result < 0:
            print("error")
            return 
        self.__balance = result



	dataclass - если класс содержит поля, чтобы не было нагромождений
https://habr.com/ru/post/415829/ 

from dataclasses import dataclass

@dataclass(frozen=True)
class Book ():				frozen -  поля не изменяемые
	title='': str (аннотация обязательна)

book=Book(title='PIZDEC')

	

Миксины (у класса два родительских класса, причем один содержит только поля, второй - методы)

class Set45and80Mixin:	- класс с полями
    def __init__(self):
        self.val1 = 45
        self.val2 = 80


class MulMixin:		- класс с методами
    def move(self):
        return self.val1 * self.val2


class Res(Set45and80Mixin, MulMixin): - объединяем поля и методы
    pass

Res().move()








		обработка ошибок
try:
	essert A() - выполняет и выводит ошибку, если что-то не то
except:
else:
finlly:

raise: ValueError(step) - вызывает ошибку принудительно

/создание собственных исключений
class MyError(Exception):
    def __init__(self, text, num):
        self.txt = text
        self.n = num

except MyError as mr:
    print(mr)                - print(self.txt, self.n)
    print(mr.args)	     - print(self.txt, self.n)
    print(mr.args[0])	     - print(self.txt)
    print(mr.args[1]	     - print(self.n)	




		Генераторы
https://skillbox.ru/media/code/generatory_python_chto_eto_takoe_i_zachem_oni_nuzhny/
https://colab.research.google.com/drive/104mHaG4W15Tcd9dFhyzkL_v-I8nTk2IN?usp=sharing

def f_gen(m):
  for i in range (m):
	yield i**2

a=f_gen(5) - объект-генератор
for i in a:
	print(i)	


 
Полезные библиотеки
import qrcode
img = qrcode.make('Лукашенко в автозак! Живе Беларусь!')
img.save("some_file.png")


from datetime import datetime as dt, timedelta as td
dt.now() - 
datetime.datetime(2022, 10, 13, 18, 51, 54, 954736)




			Фреймворки и ВЕБ





	Удобные штуки для фреймворков


	PyDantic()
from pydantic import BaseModel, ValidationError 	
PyDantic - разобрать!!!
сравнить с (str, Enum)
validator(к PyDantic)

in_data="""                       - json
{
    "city_id": 123,
    "name": "Minsk",
    "popolation": 2000000
}
"""


class City(BaseModel):		класс-экземпляр	
    city_id: int
    name: str
    popolation: int

 @validator('name')					- валидатор, проверяет определенное поле
    def name_check(cls, v: str)->str:
        if 'm' not in v.lower():
            raise ValidationError("Don't have M")
        return v



city=City.parse_raw(input_json) - экземпляр класса City

	
Оборачиваем в ValidationError
try:					
    city=City.parse_raw(in_data)
except ValidationError as a:
    print(a.json())




		Enum (для проверки, является ли объект элементом класса)
from enum import Enum
class BlogType(str, Enum):		- предопределенный путь, то есть работает когда эндпоинтом является поле класса BlogType
    short = 'short'
    story = 'story'
    howto = 'howto'

type: BlogType - то есть элемент является или short, или story, или howto


	Сокеты (на TCP)
import socket (TCP)

Серверная часть
socket_obj=socket.socket()
socket_obj.bind('127.0.0.1', PORT) - забиндеть порт (передается хост и номер порта)
socket_obj.listen(a) - прослушивание порта (a - максимальное значене для принятия)
conn, addr = sock.accept() - возвращает кортеж с двумя элементами: новый сокет и адрес клиента.
data = conn.recv(1024) - передается пакетами по 1024 байта
conn.send(data) - возвращает данные клиенту

Клиентская часть
socket_obj=socket.socket()
socket_obj.connect(('127.0.0.1', PORT)) - подключение клиента
conn.send(data) - возвращает данные клиенту
data = conn.recv(1024) - передается пакетами по 1024 байта


	Запросы(HTTP) 
import request
response = requests.get('https://api.github.com', params) - выполнить запрос GET, передав параметры
response.status_code - получить о статусе запроса (200 - окей)
response.headers - получить header
response.content - для получения инфы в байтах
response.text - перевести все в текст (выведется в более человеческом виде)
response.json()  - возвращает все в словаре

response.encoding = 'utf-8' # Optional: requests infers this internally - декодирование



Так же популярные запросы: 
report = requests.post("https://httpbin.org/forms/post", params=params) - то есть постит на сайт какую-то инфу
delete
put/patch



	Flask

From flask import Flask, render_template, send_from_directory - подключание фласка а так же библиотеки для использования файлов с html, для загрузки файла

app = Flask(__name__) - объект на основе класса Flask, в скобках указывается, какой файл запускается


@app.route('/')	- отслеживает главную страничку
def hello_world():  # put application's code here
    return 'Hello World!'

@app.route('/user/<string:name>/<int:id>') - передача параметров через url строку
def user(name, id):
	return send_from_directory('path_to_file', filename) - загружает файл

if __name__ == '__main__':
    app.run(debug=True/False) -  запускает flask и ставит файл для вывода ошибки






		FastApi
https://colab.research.google.com/drive/1V49WZaqYt6i4CALDuALAXc6VFYBt8v7W

uvicorn main:app --reload - запуск сервера
http://127.0.0.1:8000/docs - получить док о сервере

from fastapi import FastAPI

app = FastAPI()


	Path-параметры

@app.get("/")     - ендпоинт
async def root():

@app.get("/hello/{name}")		- эндпоинт с переменной (динамический ендпоинт)#если на месте динаического эндпоинта писать другой, то вначале пишется обычный, потом динамический
async def say_hello(name: str):
    return {"message": f"Hello {name}"}



	Enum
from enum import Enum
class BlogType(str, Enum):		- предопределенный путь, то есть работает когда эндпоинтом является поле класса BlogType
    short = 'short'
    story = 'story'
    howto = 'howto'

@app.get('/blog/type/{type}')
def get_blog_type(type: BlogType):
  return {'message': f'Blog type {type}'}




	Query-параметры (URL параметры (передаются после ?))
from typing import Optional
@app.get("/blog/all")
def get_blogs(page: int = 1, page_size: Optional[int] = None): - здесь сразу установлены по дефолту, Optional[int] - установленный тип
    return {"message": f"All {page_size} Blogs on {page}"}



	Статус-коды
from fastapi import FastAPI, Response, status

@app.get('/blog/{id}', status_code=status.HTTP_200_OK)  - передаем статус-код по дефолту
def get_blog(id: int, response: Response):	- статус-код передается как response (response вообще является телом ответа)
  if id > 5:
    response.status_code = status.HTTP_404_NOT_FOUND - замена статус-кода
    return {'error': f'Blog {id} not found'}
  else : 
    response.status_code = status.HTTP_200_OK   
    return {'message': f'Blog with id {id}'



ЛИБО:
from starlette.exceptions import HTTPException
from starlette.status import HTTP_404_NOT_FOUND

@app.get('/blog/{id}', status_code=status.HTTP_200_OK):
def get_blog(id: int):
	if id>5:		
		raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="some exception")
	else: 
		return {'message': f'Blog with id {id}'}




ЕСТЬ ЕЩЕ EXEPTION_HANDLER (отлавливает ошибки на всех ручках):
from starlette.responses import JSONResponse
@app.exception_handler(Exception) - передаем ex, который нужно обработать
async def internal_exception_handler(_, exc: Exception):
    return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        content={
                            "code": status.HTTP_500_INTERNAL_SERVER_ERROR,
                            "is_error": True,
                            "message": f"An error occurred: {exc}"
                        },
                        )



	Декорации в swagger

@app.get("/hello/{name}", tags=["utils"], description = "desc") - теги, то есть группировка, desc... - то же самое, что и с """sf"""
def say_hello(name: str):
    """description""" 			   - будет отражаться в swagger как description (описание)
    return {"message": f"Hello {name}"}

@app.get("/hello/{name}", summary="asdf") - sum - название функции, изначально равняется имени функции


	Роутинг (раскидывание точек по файлам)


		



	Роутеры (мы можем разнести наши куски url по разным файлам с одинаковыми кусками url)
from fastapi import APIRouter

news_router = APIRouter(prefix='/news', tags=['news']) - то есть все url этого файла будут начинаться с /news

app.include_router(news_router) - пишется в файле, к которому подключается роутер





		ТелеБоты
import telebot
bot=telebot.TeleBot('5955331741:AAEGnEuaYXUNFB2aWpET4roxakxlOocn3ys') - подключение токена бота

@bot.message_handler(content_types=['text', 'document', 'audio']) - метод для получения текстовых сообщений 
def get_text_messages(message): 
	pass

bot.register_next_step_handler(message, get_name); #следующий шаг – функция get_name

bot.send_message(message.from_user.id, "Привет, чем я могу тебе помочь?") - отправить сообщение пользователю (передается id пользователя и текст)

bot.polling(none_stop=True, interval=0) - запускаем нашего бота, постоянно спрашивает у севера на наличие ему письма


keyboard = types.InlineKeyboardMarkup(); создает поле с кнопками
key_yes = types.InlineKeyboardButton(text='Да', callback_data='yes'); #кнопка «Да»
keyboard.add(key_yes); #добавляем кнопку в поле с кнопками 
bot.send_message(message.from_user.id, text="smthng", reply_markup=keyboard)



		Django

https://colab.research.google.com/drive/1mdHSjzuc_m8PbJsWRLGXm6WzxCrxZ-f9	

	Скрипты для консоли
django-admin startproject samplesite - создать джанго-проект (config)
python manage.py startapp new_app - создать приложение (все необходимые файлы приложения)
python manage.py runserver 40000 - запустить сервак на 40000 порту (можно не писать цифры, тогда он автоматически запустит)
python manage.py createsuperuser - создание суперюзера, который сразу помещается в бд

python manage.py makemigrations - создать или обновить все таблицы (грубо говоря как add, то есть задаются команды для ORM)
python manage.py makemigrations bboard - создать и обновить все таблицы указанного проекта 
python manage.py sqlmigrate bboard 0001 - представление кода на sqlite
python manage.py migrate - создание таблицы


Основной порядок:
1. migrate
2. superuser
3. runserver



		Работа с ORM Django (для заполнения таблицы), использование консоли Django
https://colab.research.google.com/drive/1ZdDr-LM41n2Uc3BGj5RxHTDPu4tWKOwg?usp=sharing#scrollTo=UshhfiHKd3b5
python manage.py shell - переход в консольл Django для удобной работы с бд
exit() - выйти из консоли

	Создание таблицы (в файле models.py)
(Для отображения таблицы в админке нужно в админе указать следующее: admin.site.register(product) )


class First(models.Model):   #наследуемся от спец класса
name=models.ClassName(...)

	Классы полей
CharField(max_length=) - поле для строки огранич длины (!max_length - указание длины)
textDField(max_length) - поле для строки неогран. длины
EmailField(max_length=) - поле для Email
URLField - интернет-адрес
SlugField(max_length, allow_unicode)
BooleanField - True/False
IntegerField - знаковое целочисленное поле обычной длины(32-разрядное).
SmallintegerField - знаковое целочисленное поле половинной длины (16-разрядное).
BigintegerField - знаковое целочисленное значение двойной длины (64-разрядное).
PositiveIintegerField - беззнаковое целочисленное поле обычной длины (32-разрядное ).
PositiveSmallIntegerField - беззнаковое целочисленное поле половинной длины (16-разрядное ).
FloatField - вещественное число.
DecimalField(max_digits=, decimal_places=) - вещественное число фиксированной точности(decimal_places - количество цифр после точки),
DateField(auto_now=True/False, auto_now_add=T/F) - значение ДАТЫ в виде объекта типа date из модуля datetime (auto_now_add - автоматически задает лату при создании, auto_now - автоматически создает дату при изменении)
DateTimeField(auto_now=True/False, auto_now_add=T/F) - значение ВРЕМЕННОЙ ОТМЕТКИ в виде объекта типа datetime
TimeField(auto_now=True/False, auto_now_add=T/F) - значение ВРЕМЕНИ в виде объекта типа datetime
DurationField - промежуток времени, представленный объектом типа timedelta из модуля datetime Python.
BinaryField - двоичные данные произвольной длины. Значение этого поля представляется объектом типа bytes.
GenericIPAddressField(protocol="IPv4 "/"IPvб"/"both", inpack_ipv4 = T/F) - поле для хранения id(protocol - тип IP адресов, inpack_ipv4 - можно ли преобразовывать IPv6 в IPv4)  
AutoField - автоинкрементное поле, короче говоря - id
SmallAutoField 
BigAutoField  
UUIDField

	Связи
rubric - models.ForeignKey("rubric", on_delete=models.CASCADE) - OneToMany связь, то есть объявляем поле в модели, указывая другое поле, первый аргумент - первичное поле, второй аргумент - действие, что делать со вторичным полем(которое создает связь) при удалении первичного, мб дальше аргументы
parent_rubric = models.ForeingKey('self', on_delete=models.PROTECТ) - модель ссылается сама на себя

Параметры для on_delete: 
CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление).

PROTECT - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели.

SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null* конструктора поля имеет значение True).

SET_DEFAULT - заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том случае, если у поля внешнего ключа бьmо указано значение по умолчанию (оно задается параметром default конструктора поля).

SET(<значение>) - заносит в поле внешнего ключа указанное значение:
	rubric = models.ForeingKey(Rubric, on_delete=models.SET(l))
	или 
	def get_first_rubric():
  		return Rubric.objects.first()
	rubric = models.ForeingKey(Rubric, on_delete=models.SET(get_first_rubric)) - то есть вернет ссылку
	
DO_NOTНING - ничего не делает.
 
Дополнительные параметры:
rubric = models.ForeignКey(Rubric, on_delete=models.PROTECT,
limit_choices_to={'show': True} - как фильтрация, заданная списком параметров, выведет только соответствующие данные
related_name='entries' -  имя атрибута записи первичной модели, предназначенного для доступа к связанным записям вторичной модели, в виде строки(first_rubric.entries.all())
related_query_name='entry' - имя фильтра, которое будет применяться во вторичной модели для фильтрации по значениям из записи первичной модели (то есть если изменен id	):
db_constraint - если True, то в таблице базы данных будет создана связь, позволяющая сохранять ссылочную целостность;
) 
to_field - имя поля первичной модели, по которому будет выполнена связь, в виде строки. Такое поле должно быть помечено как уникальное (если связано не через id)
 
 
 
 
OneToOneField(<вторая связываемая модель> [, <остальные параметры>]) - OneToOne 

ManyТoManyField(<вторая связываемая модель> [, <остальные параметры>]) - ManyToMany
Доп параметры для ManyToMany:
limit_choices_to - фильтрация как и с OneToMany
related_name - имя записи первичной модели для поиска во втоиичной
related_query_name - как и в OneToMany
db_constraint

 
 
 
 	Параметры, поддерживаемые полями всех типов: 
 verbose_name - "человеческое" название поля, которое будет выводиться на вебстраницах. 
 db_column - имя поля таблицы в виде строки.
 help_text - дополнительный поясняющий текст, выводимый на экран.
 default - значение по умолчанию
 unique - уникальное во всей таблице
 unique_for_date - поле, сохраняющее значение при условии, если уникальны в пределах даты
 	title = models.CharField(max_length=50,unique_for_date='published')
	published = models.DateTimeField()
	
unique_for_month - что и _date, только с месяцем
unique_for_year - что и _date, только с годом
null=True/False - может ли поле быть пустым
blank = True/False - может ли строка быть пустой
primary_key - если True, то текущее поле станет ключевым. (обязательно к зап. и уникально, при этом удаляется id)
editable - запрещает изменять значение поля в админ-панели
db_index = True - индескирует полея, помогает искать объекты тем, что создает новую таблицу с полем необходимого вида (одинкаковое значение)

	
	Мета класс - для настройки класса-модели (пишется внутри класса-модели)	
class Meta:
	verbose_name = "Книга"  # переименование всей таблицы в админке
	verbose_name_plural = "Книги" #переименование таблицы во множественном числе (тоже в админке)
	ordering = ('-title', 'published')  # сортировка записей в определенном порядке (т.к. -title, то сортируется по title в обратном порядке)
	unique_together=('title', 'published_date') #уникальность: не может быть создана запись с одинаковым именем и датойвместе
	get_latest_by=["published", "edited"] - определяет старшесть его записи в соответствии с заданными полями (потом исп при latest(), earliest())
	index_togeteher=[['published', 'title'], ['title', 'price', 'rubric']] - индексация вместе, то есть сразу создаются доп таблицы, рассортированные по группам
	default_related_name - имя атрибута записи первичной модели, предназначенного для доступа к связанным записям вторичной модели (то есть на все related_name устанавливает default значение)
	db_name - название таблицы в БД
	


	Запросы и добавления 
from bboard.models import product as prod - импортируем нашу таблицу из проекта
b1= prod(title='Дача', content='Some info', price = 5000) - создание записи модели

b2 = prod()				#можно все записывать и в несколько строк
b2.title = 'Автомобиль'
b2.content = '"Жигули"'
b2.saves.add(obj) - добавление MtM записи
b2.save()


b2.title - то есть вывоит поле объекта
b.delete() - удаление этого поля с таблицы
b1.save() - сохранить результат в таблицу
b1.pk - проверка на сохранность



	Все через менеджер object:
	
prod=Product()
prod.objects.create(title='Дом', content='Трехэтажный, кирпич', price=50000000) - создание и сразу же сохранение 

prod.objects.all(): -  возвращает набор записей — последовательность из всех записей модели
prod.objects.all()[n] - вернет именно n запись  
Bb.objects.order_by('title'): - сортирует записи по значению поля, имя которого указано в параметре, и сразу же возвращает набор записей
Bb.objects.filter(title='Дом'): - фильтр по критериям, возвращение списка
Bb.objects.filter(user_username="adam69") - то есть мы можем делать фильтрацию, напрямую оьбращаясь к имени...
b = Bb.objects.get(pk=2) - ищет первую подходящую запись и возвращает в качестве аргумента
Bb.object.latest()/earliest() - выдаст самую поседнюю/самуб первую добавленную запись

Employer.objects.filter(boss__user__username='root') - пример, как использовать фильтр и многошаговый запрос (ищем сотрудников, где имена боссов равны root)
К этому так же есть различные доп аргументы: https://docs.djangoproject.com/en/4.1/ref/models/querysets/#field-lookups
	__contains - внутри слова
	__iconstains - без учета регистра
	__in - в диапазоне [] 	
	__gt - >
	__gte - >=
	__lt - <
	__lte - <=
	...
	
	Q класс:
Employer.objects.filter(Q(boss__user__username__contains='ad') |/& Q(id_in=[1, 2, 3])) - или / и
Employer.objects.filter(-Q(boss__user__username__contains='ad') |/& Q(id_in=[1, 2, 3])) - отрицание 

	F класс:



[i for i in dir(User.objects.all()[2]) if "set" in i] - получить все возможные поля, которые можно запросить из таблицы, в которых есть set



	Запрос записи из первичного поля ко вторичному (то есть из поля, в котором нет внешнего ключа к полю, в котором присутствует внешний ключ) а так же запросы с разными связями

	
	
	
Если OneToMany: User.book_set - то есть мы можем добыть связь от User к Book, при этов OneToOne в Book  (мы можем изменить book_set при помощи параметра related_name во вторичной(где ForeignKey) таблице) вернется менеджер, для QuerySet исп all()
	
Если OneToOne: Просто используем название таблицы: User.objects.first().employee (где User - перв, employee - втор), возвращается объект


Если ManyToMany: как и с OneToMany обращаемся по related_namу, при этом возвращается менеджер: User.objects.first().employee (где User - перв, employee - related_name)
		 Запись: new_3.boss.add(emp_root), где new_3 - запись табл первичной, boss - поле MtM, emp_root - объект записи
		 









	HttpResponse
return HttpResponse(s, content_type='text/plain; charset=utf-8') - возвращает значение в виде строки с заданной кодировкой (изначально задается как html)


вопросы: 
разбор запросов

@recieve - сигналы
@property
slug


Вопросы на заятие:
Как определить нужный процесс в менеджере

Как добавлять запись при self

вопрос со скрина 



 
