# - однострочный коммент
'''a''' - многострочный коммент	

a.__dict__ - узнать все функции объекта
a.__doc__ - получить документацию об объекте
a.__sizeof__ - узнать размер данных


	Типы данных, переменные, работа с переменными
id(a) - узнать адрес памяти
type(a) - узнать тип переменной int(input()) - преобразование из строки в целое число

float(input()) - преобразование из строки в любое число
bool() - логический тип данных
str() -перевод символа в строку
int() - в целое число 
	

	Аннотации (для разработчика, т.е. только подсвечивает)

a: int = 5 - переменная принимает только int значения
def funct(a: int, b: int=11 )->int - добавляем аннотацию в функцию, аргументы определенного типа, return определенного типа
funct.__annotation__  - получить аннотацию

Для коллекций:
from typing import List, Tuple, Dict - используем библиотеку для аннотации коллекций
lst: List[str] - список будет состоять только из строк
d: Dict[str, int] = {'a': 100} словарь с аннотацией


Сборка:
from typing import Any, Union, Optional

a: Any = 1 - любой тип данных
b: Optional[int] = None - переменная принимает либо ничего, либо int
с: Union[int, str] - может принимать несколько значений
с: int|str - Union




	Формы операторов присваивания

a = 'a'                 # Каноническая форма
a, b = 'A', 'b'         # Присваивание кортежей
[a, b] = ['A', 'b']     # Присваивание списков
a, b, c, d = 'test'     # Присваивание последовательностей (каждой букве соответсвует символ строки)
a, *b = 'test'          # Операция распаковки последов (*b берет оставшиеся части строки).
a = b = 'test'          # Групповое присвоение одного знач.
a += 1                  # Комбинированная инструкция присв.
a, b = b, a             # Обмен значениями
x1, x2, x3 = false, 1, a - распаковка ( присваивание идет по очереди)
1<=a<=100 - упрощение записи

	Запаковка/Распаквка

num=[1, 2, 3, 4]
more_num=[*num, 11, 18] - распаковка, то есть весь список/множество/кортеж/ключ словаря превращаются в обычне значения(не длежат в одной "ячейке")

a, *b=1, 2, 3 - запаковка, т.е. в b входят оставшиеся элементы

date_info = {'year': '2020', 'month': '01', 'day': '7'}
>>> event_info = {**date_info, 'group': "Python Meetup"} - распаковка словаря (удобно при создании нового словаря)


	Функции ввода/вывода
name = imput ("ввод") - вводит в переменную данные с клавиатуры (в скобках указ. требования)
a, b, c = input() - вводится безпрервывно, но на каждую букву соответственно один символ
input('Введите имя игрока № {}'.format(str(i+1))) - вместо фигурных скобок вставляется значение

print (name) - вывод 
print(1, 2, sep=".", end=".", file="file", flush) - : sep - способ разделения выводимых значений (изначально задан пробел)
						      end - как заканчивать вывод (изначаьлно \n)
						      file - в какой файл выводить (изнчально консоль)



		Строки
 len(s) - Узнать количество символов (длину строки) можно при помощи функции .
S[i] — это срез, состоящий из одного символа, который имеет номер i
S[0] - первый символ
S[-1] -последний символ 
S[:i] - читаются символы до i
S[i:] - читаются символы от i
a in b - строка a внутри строки b
len(l) - узнать длину строки l
S[a:b:d] - срез от a до b с шагом d


Методы
S.find("e") - находит первый индекс 'е' в строке, если такого символа нет, то выдаст -1
S.rfind("e") - находит последний индекс 'е' в строке
S.index(a) - возвращает индекс, если нету, выводит ошибку
S.split(' ') - разделяет строку на подстроки в местах пробела (в данном случае)
S.isdigit() - проверяет на цифры

s.count('aa') - находит колличество строк 'аа' в строке 
s.replase('a', 'A', 2) - замена первых 2 а на А в строке s
S.upper() - переводдит все к верхнему регистру
s.lower() - переводит все на нижний реистр
 print(“““ первая строка
вторая”””) - выводит на разных строках
s.join(a) - добавляет в строку список или другую строку	
S.capitalize() - делает, чтобы первое слово с большой буквы
S.title() - каждое слово с большой буквы
S.strip() - полученную строку приводит к строке со словами, разделенными пробелами
S.startswith("a") - проверяет, начинается ли строка с данного слова
S.endswith('string') - проверяет, заканчивается ли строка на данное слово
\n - enter


	Форматирование строк

Оператор %
'Hello, %s %s' %(first_name, last_name)	- первый способ
'Hello, %(first_name)s %(last_name)s' %('first_name':first_name, 'last_name':last_name) - c переменными
'Hello, %.1s%.1s' % (first_name, last_name) - берет только первую букву
print('%(x)f + %(y)f = %(z)f' % {'x': x, 'y': y, 'z': x + y}) - работа с числовыми значениями 

Метод .format
'Hello, {} {}!'.format(first_name, last_name) - вставляется по порядку
'Hello, {1} {0}!'.format(first_name, last_name) - вставляется по номеру
'Hello, {first_name} {last_name}!'.format(last_name=last_name, first_name=first_name) - втавляется по имени
print('{x:.2f} + {y:.2f} = {z:.2f}'.format(x=x, y=y, z=x + y)) - с использованием чисел и их дрбной частью

f-строки (f-string)
f'Hello, {first_name} {last_name}' - по переменным
print(f'{x:.2f} + {y:.2f} = {x + y:.2f}') - c числовыми значениями 



	Итерабельные типы данных (списки, словари, кортежи, множества)
___________________________________________________________________________________________________________________________________________	

		Списки
a=['1', 2, True]
a=list('123456') - перевод строки в список (a=['1', '2', '3', '4', '5', '6'])
 c = [c * 3 for c in 'list'] - генератор списка

Операторы:
a=[1]
a*n - список повторит каждый элемент n раз
a+b - объединяет два списка

Функции
len(a) - длина списка
min(a) - наименьший элемент списка
max(a) - наибольший элемент списка
sum(a) - сумма всех элементов (только числа)
list(zip(a, b)) - создает список кортежей (то есть объединяет несколько списков, множеств, кортежей или словарей в список кортежей)

Методы
a=x.copy() или a=list(x)- копирует список (если через приравнивание, то переменная указывает на одно и то же место, и при изменении одной переменной изменяется и другая)
f in a - проверяет, есть ли f
x.index(n) - вернет индекс первого найденного элемента
x.count(n) - вернет количество элементов
x.append(n) - добавляет новый элемент в конец списка
x.insert(a, 'test') - вставляет test в место со значением a
x.sort() - сортирует список
x.sort(reverse = true) - сортирует список в обратном порядке
x.remove(n) - удаляет первый элемент 
x.pop() - удаляет последний элемент, выводит удвленный элемент
x.pop(2) - удаляет второй элемент с конца, выводит удвленный элемент
s=', '.join(x) - создает строку, слова которой является элементами списка, разделенными ', '
x.extend(listToAdd) - добавляет в список элементы с другого списка
x.clear() - очищает список

Генератор 
[x * x for x in range(10)]
[x * x for x in range(10) if x % 2] - генератор с условием


	
	Кортеж
Объявление
x=tuple()
x=('a',) 
x=(1, 2, 3, 4, 5)
x=1, 2, 3

Операции
x=(1, 2)
y=(3, 4)
x, y = y, x - обмен значений


	Словарь
Объявление 
x={}
x=dict()
x={'Alex': None, 'Brian': {'age': 15, 'gender': male}} - словарь в словаре

Операции
x['key'] - вывод значения, если его нет, он создается (вывод значение делать )
x['Alex']={'age':17} - добавление нового элемента
x.del['Alex'] - удаляет 

Функции
dict(zip(a, b)) - создает словарь(то есть объединяет несколько списков, множеств, кортежей или словарей в список кортежей)

Методы 
x.update({'Alex':{'age':17}}) - перезаписываем словарь, то есть если есть такие элементы, они перезаписываются, если новые - добавляются
x.get('key') - вывод значения
x.pop() - удаляет последние значения
x.values() - возвращает все значения
x.keys() - возвращает все ключи
x.items() - возвращает все пары

Итерация по словарям
for key, value in x.items(): - вывод пар
	print(key, value)

{v:k for k, v in e2f.items()} - поменять местами ключ/значение

Генератор
{x: x**2 for x in range(10)}
{x: x**2 for x in range(10) if x % 2} - генератор с условием



	Множества (не имеют повторяющихся элементов)
Объявление:
x=set()
x={'x'}
x=set{'abc'} - вернет {'a', 'b', 'c'}

Операции:
A|B или A.union(B)- объединение
A&B или A.intersection(B) - пересечение
A-B - разность 
A^B - симметрическая разность

Методы 
x.add() - добавляет новый элемент (неизменяемыф)
sets.update(lists, tuples) - добавляет элементы с другого множества или множеств (может быть и кортежи, и списки и все остальное)
x.remove() - удаляет элемент
x.discard() - удаляет элемент, не выдет ошибку, если нет такого элемента
x.pop() - сохраняет элемент и удаляет первый элемент (быть аккуратнее, т.к. в множестве элементы хранятся не как их задают)
x.clear() - удаляет все 

Генератор
{x * x for x in range(10)}
{x * x for x in range(10) if x % 2} - генератор с условием

___________________________________________________________________________________________________________________________________________

	условия
str.isdigit() - определяет, числовое ли значение
if 

elif

else

x or y - или
x and y - и
not x - не 

x = 'да' if False else 'нет' - сокращенный оператор
x = 'да' if a else 'нет' - сокращенный оператор
x = 'да' if False else ('нет' if False else 'совсем нет') - сокращенная запись оператора в операторе

hot_temps = [temp for _ in range(20) if (temp := get_weather_data()) >= 100] - моржовый оператор (:=), сразу сравнивает и приравнивает 



	Цикл
While ...: зацикливающееся условие
if...
while true - бесконечный цикл
  for a in 1, 2, ... -  присваевает значения переменной а
range(n) - 	for a in n
range(n, k) - от n (включая) до k (не включая)
range(n, k, l) - от n (включая) до k (не включая) через каждый l

break - остановить цикл (тогда удыу не учавствует)
else - если не устраивает условию while
continue - пропустить команды в цикле
for i in range(n) - в промежутке n
for _ in range(5): - не создает новую переменную а использует "мусорку"

a=[i.capitalize() for i in a] - генератор 

matrix = [[i for i in range(5)] for _ in range(6)] - получается матрица
		
		

	


	черепашка
import turtle - извлечь черепшку из библиотеки
t = turtle.Pen() - присваивание черепашки к числу t (все действия будут записываться через t)
t.up/down() - поднять/опустить перо
goto(x, y) - переместить черепашку в точку с координатами (x, y).Обрати внимание, что она продолжит оставлять след, если не поднять перо.
setx(n) - задать координате x значение n.
sety(n) - задать координате y значение n.
home() - переместить черепашку в точку (0, 0).
t.forward/backward(50) - перенести черепашку вперед/назад на 50 пикселей
t.left/right(90) -  поворот черепашки на 90 
t.reset - очищение холста
t.clear - очищение холста,  но при этом черепашка остается на месте
xcor() - узнать координату x черепашки 
ycor() - узнать координату y черепашки 
pos() - вернет сразу два числа - координату x и y.
t.pencolor('red') - цвет пера красный
t.width(25) - толщина пера 25
fillcolor('red') - установить цвет заливки.
t.begin_fill() -  пишем в начале, тем самымы говорим черепашке, что начиная с этой точки будет начинаться заливка;
t.end_fill() - пишем в конце, после команд, которые рисуют фигуру, после чего черепашка зальет нарисованную область цветом.
t.color('red', 'blue') - устанавливает цвет пера и заливки



	Функция и все принадлежности
______________________________________________________________________________________________________________________________________________
def hello(param): 
	print( param); - создание  функции, def - функция, hello - имя функции, param - переменная или текст
	return A - возвращение значения, можно писать несколько аргументов, вернет как кортеж, можно разбить срау на переменные при возвращении

	pass - просто для пустой функции
hello(fgh) - вызов функции, где param = fgh
hello(x=1, y=2) - передается соответственно определенным аргументам (т.е. при создании ф-ии есть переменные, они соответствуют аргументам)

Виды объявления:
def funct()
def funct(x, y)
def funct(x, y=1) - с неявным аргументом (второй аргумент передавать необязательно), 
def funct(*args) - можно передавать несколько позиционных аргументов, args в функции является кортежем, запаковывает в кортеж введенные значения
	def funct(*args, a) передается как (1, a=2)
	def funct(a, *args) можно передавать по разному
def funct(**kwargs) - можно передавать ключ:значение
	my_dict={'a':1, 'b':2}
	funct(my_dict)
	func(x=0, y=1) - сделает из этого словарь соответственно


Значение аргументов по умолчанию (в частности для нецикличного повторения)
def func(x, y = None): - работа с иколлекционными значениями, поскольку y будет у всех одинаков, в случае использования имменованного y
  if y == None:
    y = []

  y.append(x)
  print(f'x = {x}, y = {y}')


Документация функции
def my_funct():
	"""Что-то"""
my_funct.__doc__ - вернет документацию
help(my_funct) - вернет документацию




	Lambda-функции (удобно, если функция маленькая)
def funct():...
a=funct - ссылка на функцию

f = lambda x: x**2 - объявление лямбда функции, где f - ссылка на функцию (переменная, которая ссылается на функцию), возвращает x**2

f=(lambda x: 'чётное' if x % 2 else 'не чётное') - можно использовать скобки, то есть возвращает любое значение 

ids = ['id1', 'id30', 'id2', 'id3', 'id22', 'id100']
sorted_ids = sorted(ids, key=lambda x: int(x[2:])) - сортирует похожие элементы через лямбда функцию


	Map, Filter, Reduce
map(even_odd,elements) - применяет функцию even_odd к каждому элементу итерабельного объекта elements
list(map(even_odd,elements)) - интерпретирование в список
elements_by2 = map(lambda x: x*2, elements) - c лямбда функцией

list(filter(funct, elements)) - фильтрует элементы списка elements по критериям функции funct
list(filter(lambda x: x>0, elements)) 


res=reduce(sum, numbers) -применяет функцию двух аргументов кумулятивно к элементам итерируемого, необязательно начиная с начального аргумента. 
result = reduce(custom_sum, numbers, 10) - первым элементом будет 10


	
	Декораторы  (функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.)

def decorator_function(func):      - функция-декоратор (передается функция как аргумент)
    def wrapper():		   - функция-обертка
        print('Функция-обёртка!')
        func()
        print('Выходим из обёртки')
    return wrapper


#декорирование функции через присваивание
def hello_world():		   -функция для декоратора
   print('Hello world!')
hello_world=decorator_function(hello_world) - 


#декорирование функции через синтаксический сахар
@decorator_function
def hello_world():
  print('Hello world!')

@benchmark(iters=10) - это не декоратор!!! Это вызывает функцию, передавая аргументы, которая хранит декоратор, который потом декорируется
def funct(): ...


#Дополнительная инофрмация (Документирование декараторов)
https://colab.research.google.com/drive/1H0BhiXhcre5GQWRYY7kyTM9ewK3LCn2a?usp=sharing#scrollTo=RH1SIMkm5cJr
----------------------------------------------------------------------------------------------------------------------------------------------

	

	РАЗЛИЧНЫЕ МОДУЛИ
___________________________________________________________________________________________________________________________________________	
		

	Рандом
import random 
random.uniform(<Начало>, <Конец>) -  возвращает псевдослучайное вещественное число в диапазоне от <Начало> до <Конец>
random.randint(<Начало>, <Конец>) — возвращает псевдослучайное целое число в диапазоне от <Начало> до <Конец>
random.choince(<Последовательность>) — возвращает случайный элемент из любой последовательности (строки, списка, кортежа)
random.randrange(<Начало>, <Конец>, <Шаг>) — возвращает случайно выбранное число из последовательности
random.shuffle(<Список>) — перемешивает последовательность (изменяется сама последовательность). Поэтому функция не работает для неизменяемых объектов.


	Время
import time 

time.time() - количество секунд, прошедшее с начала нашей эпохи
time.ctime() - перевод секунд в удобный формат (если без аргумента, то вернет настоящую дату)
time.asctime() - получить точные данные о времени
time.sleep(n) - задержка программы на n секунд

result=time.gmtime() - получить данные в другом формате
result=time.localtime() - получить данные в другоом формате
result.tm_mday - получить отдельно день/месяц/минуту...

time_str=time.strtime('%m/%d/%Y, %H:%M:%S') - вывод даты и времени

 

	

-------------------------------------------------------------------------------------------------------------------------------------------

		Кодировка
ENCODE 
txt.encode(encoding='ascii', errors='backslashreplace')) - заменяет неизвестный символ (txt - строка, которую раскодируют)
				     backslashreplace - использовать обратный слэш (\) вместо проблемных символов
				     ignore - игнорировать проблемные символы
				     namereplace - заменить объяслением проблемного символа
				     strict- по умолчанию, вызвать ошибку
				     replace - использовать знак вопроса (?) вместо проблемных символов
				     xmlcharrefreplace - использовать символ xml вместо проблемных символов

DECODE
txt.decode(encoding='ascii', errors='backslashreplace' 
				     backslashreplace - использовать обратный слэш (\) вместо проблемных символов
				     ignore - игнорировать проблемные символы
				     namereplace - заменить объяслением проблемного символа
				     strict- по умолчанию, вызвать ошибку
				     replace - использовать знак вопроса (?) вместо проблемных символов
				     xmlcharrefreplace - использовать символ xml вместо проблемных символов






		Работа с файлом
___________________________________________________________________________________________________________________________________________

	Функция Open() https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-open/ - подробнее
file= open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
	file - абсолютное или относительное значение пути к файлу или файловый дескриптор открываемого файла.
	mode - необязательно, строка, которая указывает режим, в котором открывается файл. По умолчанию 'r'.
	encoding - необязательно, кодировка, используемая для декодирования или кодирования файла.
	errors - необязательно, строка, которая указывает, как должны обрабатываться ошибки кодирования и декодирования. Не используется в -бинарном режиме	
	newline - необязательно, режим перевода строк. Варианты: None, '\n', '\r' и '\r\n'. Следует использовать только для текстовых файлов.
	closefd - необязательно, bool, флаг закрытия файлового дескриптора.
	opener - необязательно, пользовательский объект, возвращающий открытый дескриптор файла.

mode='r'
	r - открывает файл только для чтения,
	w - открыт для записи (перед записью файл будет очищен),
	x - эксклюзивное создание, бросается исключение FileExistsError, если файл уже существует.
	a - открыт для добавления в конец файла (на некоторых Unix-системах пишет в конец файла вне зависимости от позиции курсора)
	a+ - символ обновления (чтение + запись).
	t - символ текстового режима.
	b - символ двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).


	Функции чтения файла и записи в файл

s=file.read() - прочитает весь файл
s=file.read(n) - прочитает первые n символов
s=file.readline() - прочитает одну строку
s=file.redlines() - создаст список, элементами которого будут являться строки 
file.seek(n) - откатить каретку на n-ый символ

for row in file: - по каждой строке из файла
	for letter in row: - по каждой букве из строки

with open('info.txt') as f: - выполнение нескольких функций дновременно 
  print(f.read())

file.write('hi') - запишет в файл
f.writelines(cfg_lines) - запишет список в файл



-------------------------------------------------------------------------------------------------------------------------------------------


