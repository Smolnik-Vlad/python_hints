			Индексы:
Индексы в базах данных используются для ускорения поиска и фильтрации данных. В PostgreSQL поддерживаются различные типы индексов:

B-tree - наиболее распространенный тип индекса в PostgreSQL. Он используется для индексирования значений, которые можно сравнивать операторами <, <=, =, >= и >. B-tree индексы хранятся в виде сбалансированного дерева, где каждый узел содержит несколько ключей и ссылки на поддеревья. Пример использования: поиск по фамилии в таблице сотрудников.

Hash - индекс, используемый для быстрого поиска точных совпадений. Он хранит хеш-коды значений и ссылки на соответствующие записи в таблице. Hash индекс может быть полезен для поиска по столбцам с большим количеством повторяющихся значений, например, статусов заказов.

Индекс GIST (Generalized Search Tree) - это обобщенное дерево поиска, которое может использоваться для различных типов данных. Он работает следующим образом:
Данные разбиваются на блоки (называемые "страницами"), которые затем добавляются в дерево.
Каждый узел дерева содержит информацию о блоке данных, а также о том, как сравнивать их.
При поиске значения в индексе, дерево проходится от корня к листьям, используя информацию о сравнении, чтобы определить, в каком направлении искать.


Индекс SP-GIST (Space-Partitioned Generalized Search Tree) - это вариант индекса GIST, который разбивает пространство на части, что позволяет более эффективно хранить данные с пространственными координатами. Он работает следующим образом:
Пространство разбивается на непересекающиеся области (называемые "квадрантами"), которые затем добавляются в дерево.
Каждый узел дерева содержит информацию о квадранте, а также о том, как сравнивать их.
При поиске значения в индексе, дерево проходится от корня к листьям, используя информацию о сравнении, чтобы определить, в каком направлении искать.

Индекс GIN (Generalized Inverted Index) - это индекс, используемый для полнотекстового поиска и поиска по массивам. Он работает следующим образом:
Данные разбиваются на токены (слова или элементы массива), которые затем добавляются в инвертированный индекс.
Каждый токен содержит ссылки на строки или элементы массива, которые его содержат.
При поиске значения в индексе, он использует токены для быстрого поиска соответствующих строк или элементов массива.

BRIN (Block Range INdex): индекс, который разбивает таблицу на блоки и хранит информацию о минимальном и максимальном значении каждого блока. Он позволяет быстро находить блоки, которые могут содержать интересующие нас значения, и пропускать блоки, которые точно не содержат нужных значений. Пример использования: поиск по временным рядам.




			ACID

ACID atomicity, consistency, isolation, durability:

atomacity - атомарность: гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние.

consistency - согласованность: в общем, данные в БД находятся в состоянии, которое соответствует правилам и ограничениям БД. Когда происходит изменение данных в БД, например, при выполнении транзакции, то согласованность БД может быть нарушена. Поэтому, для того чтобы сохранить согласованность, БД включает в себя механизмы контроля целостности данных и транзакций. Грубо говоря как закон сохранения массы: что-то куда-то переписалось, данные должны быть такими же. Или же в один момент времени данные не противоречат друг другу

isolation - Изоляция: Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Уровни изоляции описаны ниже

durability - Устойчивость: Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.




			УРОВНИ ИЗОЛЯЦИИ
Уровень изоляции транзакций - это механизм, который определяет, как одна транзакция видит изменения, внесенные другой транзакцией в одни и те же данные. В SQL-сервере существует четыре уровня изоляции транзакций:

READ UNCOMMITTED (неподтвержденное чтение) - это самый низкий уровень изоляции, при котором транзакция может видеть изменения, внесенные другой транзакцией, которая еще не завершилась. Этот уровень может привести к проблемам с целостностью данных. (dirty read, non-repeateble read, phantom read). Для защиты используется механизмы версионирования данных для контроля доступа к изменяемым строкам.

READ COMMITTED (подтвержденное чтение) - это уровень изоляции, при котором транзакция не может прочитать данные, которые были изменены другой транзакцией, но еще не подтверждены. Таким образом, этот уровень изоляции обеспечивает более высокую степень защиты от проблем с целостностью данных, чем уровень неподтвержденного чтения (Read Uncommitted).
Однако уровень Read Committed может приводить к проблеме "неповторяемого чтения" (non-repeatable read), когда транзакция может видеть изменения в уже прочитанных строках, если другая транзакция обновила эти строки между двумя чтениями первой транзакции.  
Использует блокировки для изоляции транзакций и предотвращения чтения изменяемых данных, которые еще не были подтверждены другими завершенными транзакциями.

Повторяемое чтение (Repeatable Read) - это уровень изоляции транзакций в СУБД, при котором транзакция может видеть только те данные, которые были считаны на момент ее начала, и не видит изменения, внесенные другими транзакциями в эти данные в процессе ее выполнения.
Это означает, что если транзакция считала некоторые данные, то она может быть уверена, что они не будут изменены другой транзакцией до того момента, пока она сама не завершится. Таким образом, повторяемое чтение обеспечивает более высокую степень изоляции, чем уровень READ COMMITTED, но менее строгую, чем SERIALIZABLE.

Однако повторяемое чтение может привести к проблеме "фантомного чтения", когда транзакция видит новые строки, добавленные другой транзакцией в процессе ее выполнения.

Фантомное чтение возникает, когда одна транзакция выполняет запрос на чтение данных, затем другая транзакция вставляет новые строки в таблицу, которые соответствуют условиям запроса первой транзакции, и затем первая транзакция выполняет тот же запрос еще раз, но уже видит новые строки.

Блокирует строки, которые были считаны в рамках транзакции, и не разрешает другим транзакциям изменять эти строки до завершения первой транзакции.

SERIALIZABLE (сериализуемое выполнение) - это самый высокий уровень изоляции, при котором транзакция видит данные так, как если бы она была единственной выполняемой транзакцией. Этот уровень обеспечивает наивысшую степень защиты от конфликтов параллельных транзакций, но может привести к блокировкам.

Самые строгие механизмы блокировки для обеспечения наивысшей степени защиты от конфликтов параллельных транзакций. В этом режиме транзакция блокирует все строки, которые соответствуют условиям ее запроса, и не разрешает другим транзакциям изменять или вставлять данные в эти строки до ее завершения.



Проще: 
Read uncommited: избавляет от потери данных. То есть если 2 транзакции изменяют какую-то запись, например, первая транзакция поменяло поле на 1, но не сделала коммит, и тут же вторая транзакция поменяла значение на 2, то при коммите сохранится значение 2. Решение: блокировка транзакций во время записи. Проблемы: dirty read, phantom read, non-repeatable read

Read commited: решает проблему dirty read: например, когда в ячейке 1, 1-я транзакция меняет значение на 2, не коммитит. Тут 2я транзакция читает и возвращает значения, а 1я транзакция откатывается обратно. Решение: можем прочесть строку только тогда, когда она будет успешно закоммичена. Проблемы: phantom read, non-repeatable read

Repeatable-read: решает проблему non-repeatable read. Момент, когда идет 2 раза чтение строки, и в этот момент времени транзакция влетает и меняет значение. Решение: блокировка записи в строку во время чтения. Проблемы phantom reading. 

Serialisable: решает проблемы фантомного чтения. То есть, когда мы, например, читаем таблицу полностью, а транзакция решила вставить строку. То есть она не изменяет во время чтения (не нарушает repeatabe-read), а просто вставляет новую запись. Решение. Полностью блокировка того поля записей, которые подходят под запрос. То есть транзакции начинают работать синхронно. Проблема: при большой нагрузке все становится в очередь, что сильно нагружает проуессор и змамедляет время. 

Решение: MVCC (Multiversion Concurrency Control): то есть каждая транзакция берет snapshot (виртуальный слепок базы) базы в текущий момент. И далее с ней работает. Перед коммитом идет фаза валидации. Если во время нашей транзакций не было никаких изменений, до коммитим данные. Если же были какие-то минимальные изменения, то делаем rollback, даже если в транзакции просто было чтение. 

Есть 2 отметки: xmin(номер  транзакции, которая сделала запись) и xmax(номер транзакции, которая удалила запись), при update запись удаляется и создается новая



			CAP
Теорема CAP:
C - Consistency (Согласованность): Это означает, что все клиенты системы должны иметь одинаковый доступ к данным в любой момент времени. Если данные были изменены, то все последующие запросы должны возвращать обновленные данные.

A - Availability (Доступность): Это означает, что система должна быть доступна для клиентов в любое время. Клиенты должны иметь возможность получать ответы на свои запросы, даже если часть системы вышла из строя.

P - Partition tolerance (Устойчивость к разделению): Это означает, что система должна продолжать функционировать даже в случае разделения сети на несколько частей. Другими словами, система должна быть способна обрабатывать запросы даже в том случае, если не все ее компоненты доступны.

Гласит, что одновременно может быть только 2 пункта. 




			МАСШТАБИРУЕМОСТЬ
Масштабируемость
1. вертикальная: когда накидываем железо
2.  горизонтальная: когда создаем много серваков и раскидываем между ними задачи
	горизонтальное делется на: репликацию, секционирование, шардинг
	
Репликация: банально раскидываем на несколько серверов, все данные на черверах одинаковы и получается распределение нагрузки. 
	Используется при респределении данных (чтобы запрос с Беларуси не летел в США), а так же при балансировки нагрузки. 
	При таком масштабировании существует 2 роли master-server(который делает изменения) и slave-server(который переписывает себе данные)
	
	Соответсвтенно существует несколько видов репликаций: master-slave(запись происходит только через master, чтение же происходит через slave. Когда из системы выпадает master, slave между собой договариваются, кто будет master) 
							      master-master(все могут записывать и читать. Проблема - сложность реализации: проблема конфликтов)
	
	Гарантии репликации: 
	1. Синхронная (мастер-сервер не поддерживает транзакцию до того момента, пока реплика не подтвердит данные). Проблема: долго. Надо ждать самое долгое подтверждение 
	2. Асинхронная (не ждет подтверждения)
	3. Majority (ждет подтверждения данных от N-реплик)
	
	Есть такое понятие как физическая и логическая репликация. При физической репликации подтягивается все файлы. При логической же делаются соответствующие запросы. 
	

Секционирование - разбиение больших таблиц на логические части по выбранным критериям. 
Варианты секционирования: 
	по диапазону значений
	по точному списку значений
	по хэшу
	по ключу
	

Шардинг - разделение данных на уровне ресурсов, в результате которого данные размещаются 

Вертикальный шардинг - выделение таблицы илигруппы таблиц на отдельный сервер
Горизонтальный - разделение одной таблицы на разные сервера. Необходимо при большой таблице, которая не помещается на один сервер. 
	Одна и та же табл. на нескольких черверах
	В прилож. выбирается условие, по которому идет разделение данных
	Перед каждым обращением происходит нужное соединение. 
	
	
Короч, шардинг просто разделяет таблицы на несколько серверов. Основные минусы - шардинг также может быть сложным в настройке и управлении, особенно если данные неоднородны или если они изменяются часто.

	Системы обработки данных: 
		OLTP (online transaction processing)- оперативная обработка транзакций (то есть дефолтное использование, добавил, удалил, считал и тд)
		OLAP (online analitical processing) - оперативная аналитическая обработка. (Используется для быстрого получения данных, данные хранятся по характеристикам, то есть создается таблица с какими-то характеристиками, и чтобы запись соответствовала определенной характеристике)
		
		OLTP - для прогеров
		OLAP - для аналитиков
		
		Хороший пример, когда вначале система обработки OLTP (для прогеров), а далее ночью перебрасывается в OLAP
		
		
В NoSql используется горизонтальное масштабирование, а именно шардинг. 
В NoSQL базах данных также используются различные технологии для повышения производительности и доступности, такие как кэширование, репликация и индексирование. Например, кэширование может использоваться для уменьшения количества запросов к базе данных, репликация может использоваться для обеспечения отказоустойчивости и увеличения доступности данных, а индексирование может использоваться для быстрого поиска данных.


		WAL

WAL (write ahead loging) - метод записи транзакции в журнал (WAL log), который обеспечивает целостность данных и отказоустойчивость. 
Компоненты WAL процесса: 
	Журнал транзакций (WAL log) - файл, в котором записываются все изменения данных в базе данных.
	Буфер журнала (WAL buffer) - область памяти, в которую записываются изменения данных до того, как они будут записаны в журнал транзакций.
	WAL writer - процесс, который записывает данные из буфера журнала в журнал транзакций на жесткий диск.	


Когда идет запись на жесткий диск:
	После того, как транзакция завершается, данные из буфера журнала записываются в журнал транзакций на жесткий диск. (В буфер записывается заранее)
	После того, как данные успешно записаны на жесткий диск, транзакция считается завершенной.


Как происходит репликация базы через журнал:
	Журнал транзакций может использоваться для репликации данных на другие серверы.
	Копия журнала транзакций отправляется на другой сервер, где она применяется к копии базы данных на этом сервере.
	После применения журнала транзакций на другом сервере, данные на обоих серверах будут синхронизированы.
	
	
Процесс транзакции с использованием метода WAL (Write-Ahead Logging) в базе данных может быть описан следующим образом:

Начало транзакции: транзакция начинается, когда приложение отправляет запрос на изменение данных в базе данных.

Запись в буфер журнала: данные изменения записываются в буфер журнала (WAL buffer) в оперативной памяти.

Запись в журнал: после записи в буфер журнала, данные изменения записываются в журнал транзакций (WAL log) на жесткий диск. Это происходит синхронно и гарантирует, что изменения будут сохранены, даже если произойдет сбой системы.

Применение изменений: после записи в журнал, данные изменения применяются к самой базе данных.

Завершение транзакции: если все изменения успешно применены к базе данных, транзакция считается завершенной. Запись о завершении транзакции также записывается в журнал транзакций.

Откат транзакции: если произошла ошибка при применении изменений к базе данных, транзакция откатывается. Для этого данные из журнала транзакций используются для восстановления состояния базы данных до начала транзакции.

В результате, использование метода WAL позволяет обеспечить целостность данных и отказоустойчивость базы данных, а также поддерживает возможность восстановления данных в случае сбоя системы.





		Vacuum
		
Vacuum - это процесс, который удаляет неиспользуемые данные из базы данных PostgreSQL. Удаление данных происходит путем освобождения места, занятого удаленными записями, и помечения этого места как доступного для повторного использования.

Как работает Vacuum:

Vacuum сканирует таблицы базы данных и помечает неиспользуемые данные для удаления.
Удаление происходит в два этапа: сначала помеченные данные переносятся в специальный файл (vacuumed), а затем они удаляются окончательно.
В процессе удаления Vacuum также обновляет статистику таблицы, чтобы оптимизировать запросы к ней.
Можно ли выключить Vacuum:

Vacuum не может быть полностью выключен, так как он необходим для поддержания целостности базы данных.
Однако, можно изменить настройки Vacuum для уменьшения его влияния на производительность базы данных.
Autovacuum:

Autovacuum - это автоматический процесс Vacuum, который запускается PostgreSQL для поддержания целостности базы данных.
Autovacuum запускается автоматически при достижении определенного порога уровня свободного места в таблицах базы данных.
Autovacuum также может быть настроен для запуска с определенной периодичностью.
Autovacuum workers:

Autovacuum workers - это фоновые процессы, которые запускаются автоматически при старте PostgreSQL и осуществляют работу по поддержанию целостности базы данных.
Количество Autovacuum workers можно настроить в конфигурационном файле PostgreSQL.
Увеличение количества Autovacuum workers может ускорить процесс Vacuum, но может также повлиять на производительность базы данных.
Примеры:

Если таблица содержит много удаленных записей, но не проходит Vacuum, то это может привести к уменьшению производительности запросов к этой таблице.
Если база данных содержит много таблиц, которые часто изменяются или удаляются, то можно увеличить количество Autovacuum workers для ускорения процесса Vacuum и поддержания целостности базы данных.


		SQL injection
Короче, sql-инъекция - способ взлома бд. То есть если нет защиты или валидации на серваке, можно попытаться обратиться к какой-либо строке через query-параметр, например. 
Примеры: 
test.ru/?detail=4+OR+1 # то есть в параметр добавляем кусок запроса
test.ru/?detail=4+-- # комментируем остальной кусок запроса, который после параметров
test.ru/?detail=4+UNION+SELECT+*+FROM+news+WHERE+id=4 # в транзакцию засовываем еще один запрос. 

Решение проблем:
валидация
проверка типа данных



	Explain
	
EXPLAIN - команда, которая выводит план выполнения запроса, но не выполняет его. Она позволяет увидеть, как PostgreSQL планирует выполнение запроса и какие индексы и операции будут использоваться.

EXPLAIN ANALYZE - команда, которая выводит план выполнения запроса и выполняет его. Она позволяет увидеть реальное время выполнения запроса и использование ресурсов базы данных.


		TOAST
		
TOAST (The Oversized-Attribute Storage Technique) - это механизм в PostgreSQL для хранения больших значений полей в таблицах. Когда размер данных превышает определенный порог, PostgreSQL автоматически перемещает эти данные в отдельную таблицу и заменяет их в основной таблице на ссылку на новое местоположение.

TOAST используется для хранения значений полей, таких как текст, изображения, звуковые файлы и другие типы данных, которые могут занимать большой объем памяти. Это позволяет значительно сократить размер таблицы и ускорить операции чтения и записи.

TOAST использует метод сегментации данных, при котором большие значения разбиваются на фрагменты фиксированного размера и хранятся в отдельной таблице. Каждый фрагмент имеет свой номер и может быть извлечен и объединен с другими фрагментами для получения исходного значения.


	

